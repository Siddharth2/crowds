{
    "contents" : "#' Mode\n#' \n#' Computes the mode of a vector.\n#' \n#' @param x a vector of integers / doubles\n#' @return The mode of the vector\n#' @export \nMode <- function(x) {  \n  ux <- unique(x)\n  ux[which.max(tabulate(match(x, ux)))]\n}\n\n#' Remove outliers\n#' \n#' Removes outliers outside 95% confidence interval.\n#' \n#' @param x a vector of integers / doubles\n#' @return a vector with outlier observations removed\n#' @export \nremove_outliers <- function(x, na.rm = TRUE, ...) {\n  qnt <- quantile(x, probs=c(.05, .95), na.rm = na.rm, ...)\n  H <- 1.5 * IQR(x, na.rm = na.rm)\n  y <- x\n  y[x < (qnt[1] - H)] <- NA\n  y[x > (qnt[2] + H)] <- NA\n  y\n}\n\n#' Geometric Mean\n#' \n#' Computes the geometric mean of a vector\n#' \n#' @param x a vector of integers / doubles\n#' @return The geometric mean of the vector.\n#' @export \ngeometric_mean <- function(x, na.rm=FALSE){\n  gm <- exp(sum(log(x[x > 0]), na.rm=na.rm) / length(x))\n  gm\n}\n\n\n#' Truncated Mean\n#' \n#' Computes the truncated mean of a vector\n#' \n#' @param x a vector of integers / doubles\n#' @param trunc real-value between 0 and .5 specifying the level of truncation\n#' @param na.rm removes missing values of x\n#' \n#' @return The truncated mean at (0.5, 0.95).\n#' @export \ntruncated_mean <- function(x, trunc=.05, na.rm=FALSE) {\n  qnt <- quantile(x, probs=c(trunc, 1-trunc), na.rm=na.rm)\n  x_trunc <- subset(x, x >= qnt[1] & x <= qnt[2])\n  m <- mean(x_trunc)\n  m\n}\n\n\n#' Truncated Geometric Mean\n#' \n#' Computes the truncated geometric mean of a vector\n#' \n#' @param x a vector of integers / doubles\n#' @param trunc real-value between 0 and .5 specifying the level of truncation\n#' @param na.rm removes missing values of x\n#' \n#' @return The truncated geometric mean at (0.5, 0.95).\n#' @export \ntruncated_geometric_mean <- function(x, trunc=.05, na.rm=FALSE){\n  qnt <- quantile(x, probs=c(trunc, 1-trunc), na.rm=na.rm)\n  x_trunc <- subset(x, x >= qnt[1] & x <= qnt[2])\n  m <- geometric_mean(x_trunc)\n  m\n}\n\n\n#' Trim leading and trailing spaces\n#'\n#' @param x a vector of character\n#' @return the original string, without any trailing / leading spaces\n#' @export \ntrim <- function (x) gsub(\"^\\\\s+|\\\\s+$\", \"\", x)\n\n\n#' Rank\n#' \n#' Computes the percent of entries in v that x is better than\n#' in terms of their distance from TrueValue.\n#' \n#' @param v vector of individual answers\n#' @param x crowd estimate\n#' @param TrueValue the correct answer\n#' \n#' @return The percentage of entries in v that are further from TrueValue than x.\n#' @export \nrank <- function(v, x, TrueValue, na.rm=FALSE){\n  dist <- abs(v-TrueValue)\n  m <- abs(x-TrueValue)\n  p <- mean(dist >= m, na.rm=FALSE)\n  p\n}\n\n\n#' Accuracy by group\n#' \n#' Computes the percentage correct and average relative error for a grouped data set.\n#' \n#' @param df grouped data frame\n#' @return plot of education vs. pct. correct\n#' @export \naccuracy_by_group <- function(df) {\n  summarise(df, \n            pct_correct = mean(is_correct, na.rm=TRUE), \n            av_dist = mean(rel_error, na.rm=TRUE))\n  \n}  \n\n\n#' Plot education vs accuracy\n#' \n#' computes the overall accuracy score (pct. correct) vs. education level \n#' \n#' @param df grouped data frame\n#' @return plot of education vs. pct. correct\n#' @export \nagg_plot_users <- function(df) {  \n  summarise(df, \n            pct_correct = mean(is_correct, na.rm=TRUE), \n            av_dist = mean(rel_error, na.rm=TRUE))  %>%\n    with(qplot(x=user_id, \n               y=pct_correct,\n               color=education,\n               geom=c(\"point\"), \n               data = ., \n               ylim=c(0,1),\n               ylab = \"pct correct\"))\n}\n\n\n#' Maximum sample size\n#' \n#' Computes the maximum sample size for a domain (min nr of responses of any task)\n#' \n#' @param id integer (domain id)\n#' @return the min nr of responses of any task in the domain\nmax_sample_size <- function(id) {\n  # \n  domain_data <- crowd_data %>%\n    filter(domain_id==id) %>%\n    group_by(task_id) %>%\n    summarise(count = n())\n  \n  max_sample <- min(domain_data$count)\n  return(max_sample)\n}\n\n\n#' Plot Accuracy vs Sample Size (MC)\n#' \n#' Computes the geometric mean of a vector for MC questions\n#' \n#' @param id integer (domain id)\n#' @param nr_simulations the number of random samples to average over\n#' \n#' @return plot of accuracy vs sample size\n#' @export \nsample_size <- function(id, nr_simulations){\n  \n  # set title according to domain name\n  s <- subset(crowd_data, domain_id == id)\n  domain_name <- s$name[1]\n  title <- paste(\"Crowd score vs. size of crowd - \", domain_name)\n  \n  # find maximum sample size \n  max_sample <- max_sample_size(id)\n  results <- vector(\"list\", max_sample)\n  \n  # run simulation \n  # sample i responses from population from each task\n  for (i in 1:max_sample) {\n    for (j in 1:nr_simulations) {\n      \n      # find score of sample \n      sample <- crowd_data %>%\n        filter(domain_id==id) %>%\n        group_by(task_id) %>%\n        sample_n(i) %>%\n        summarise(domain_id = id,\n                  true_answer = Mode(correct_answer),\n                  crowd_answer = Mode(answer),\n                  is_correct = ifelse(true_answer == crowd_answer, TRUE, FALSE)) %>%\n        \n        # find crowd score\n        group_by(domain_id) %>%\n        summarise(crowd_score = sum(is_correct))\n      results[[i]] <- c(results[[i]], sample$crowd_score)\n    }\n    print(i)\n  }\n  \n  # find sample mean and standard deviation\n  sample_mean <- unlist(lapply(results, mean, na.rm=TRUE))\n  sample_sd <- unlist(lapply(results, sd, na.rm=TRUE))\n  \n  # save to data frame\n  d <- data.frame(size = 1:max_sample, \n                  mean = sample_mean, \n                  se0 = sample_mean - sample_sd, \n                  se1 = sample_mean + sample_sd)\n  \n  # plot crowd score as a fn of sample size\n  ggplot(data=d, \n         aes(x=size, y=mean)) +\n    geom_errorbar(aes(ymin=se0, ymax=se1), width=.1, color=\"grey\") +\n    geom_point() +\n    ylim(0, 20) +\n    ylab(\"Average score of sample\") + \n    xlab(\"Sample size\") +\n    ggtitle(title)\n  \n  return(d)\n}\n\n\n#' Plot Accuracy vs Sample Size (point estimate)\n#' \n#' Computes the geometric mean of a vector for point estimate questions\n#' \n#' @param id integer (domain id)\n#' @param nr_simulations the number of samples to generate\n#' \n#' @return plot of accuracy vs sample size\n#' @export \nsample_size_cont <- function(id, nr_simulations){\n  \n  # set title according to domain name\n  s <- subset(crowd_data, domain_id == id)\n  domain_name <- s$name[1]\n  title <- paste(\"Crowd score vs. size of crowd - \", domain_name)\n  \n  # find maximum sample size \n  max_sample <- max_sample_size(id)\n  results_mean <- vector(\"list\", max_sample)\n  results_median <- vector(\"list\", max_sample)\n  results_trunc_mean <- vector(\"list\", max_sample)\n  results_geom_mean <- vector(\"list\", max_sample)\n  \n  # run simulation \n  # sample i responses from population from each task\n  for (i in 1:max_sample) {\n    for (j in 1:nr_simulations) {\n      \n      # find score of sample \n      sample <- crowd_data %>%\n        filter(domain_id==id) %>%\n        group_by(task_id) %>%\n        sample_n(i) %>%\n        summarise(domain_id = id,\n                  true_answer = Mode(correct_answer),\n                  score_mean = mean(rel_error), \n                  score_median = median(rel_error),\n                  score_trunc_mean = truncated_mean(rel_error),\n                  score_geom_mean = geometric_mean(rel_error)) %>%\n        \n        # find crowd score\n        group_by(domain_id) %>%\n        summarise(crowd_mean = mean(score_mean),\n                  crowd_median = mean(score_median),\n                  crowd_trunc_mean = mean(score_trunc_mean),\n                  crowd_geom_mean = mean(score_geom_mean))\n      \n      # save results\n      results_mean[[i]] <- c(results_mean[[i]], sample$crowd_mean)\n      results_median[[i]] <- c(results_median[[i]], sample$crowd_median)\n      results_trunc_mean[[i]] <- c(results_trunc_mean[[i]], sample$crowd_trunc_mean)\n      results_geom_mean[[i]] <- c(results_geom_mean[[i]], sample$crowd_geom_mean)\n      \n    }\n    print(i)\n  }\n  \n  # find sample mean and standard deviation\n  sample_mean <- unlist(lapply(results_mean, mean, na.rm=TRUE))\n  sample_median <- unlist(lapply(results_median, mean, na.rm=TRUE))\n  sample_trunc_mean <- unlist(lapply(results_trunc_mean, mean, na.rm=TRUE))\n  sample_geom_mean <- unlist(lapply(results_geom_mean, mean, na.rm=TRUE))\n  \n  sample_sd_mean <- unlist(lapply(results_mean, sd, na.rm=TRUE))\n  sample_sd_median <- unlist(lapply(results_median, sd, na.rm=TRUE))\n  sample_sd_trunc_mean <- unlist(lapply(results_trunc_mean, sd, na.rm=TRUE))\n  sample_sd_geom_mean <- unlist(lapply(results_geom_mean, sd, na.rm=TRUE))\n  \n  # save to data frame\n  d <- data.frame(size = 1:max_sample, \n                  mean = sample_mean, \n                  median = sample_median,\n                  trunc_mean = sample_trunc_mean,\n                  geom_mean = sample_geom_mean)\n  \n  # plot crowd score as a fn of sample size\n  crowd_performance <- melt(d, id=\"size\")  # convert to long format\n  \n  ggplot(data=crowd_performance,\n         aes(x=size, y=value, colour=variable)) +\n    geom_line() + \n    geom_point() +\n    ylab(\"Relative Error of sample\") + \n    xlab(\"Sample size\") +\n    ggtitle(title)\n  \n}\n\n",
    "created" : 1431323046045.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "3702622943",
    "id" : "4DD880BC",
    "lastKnownWriteTime" : 1431324812,
    "path" : "D:/Stanford/crowds/crowds/src/demo_analysis/crowds/R/power.R",
    "project_path" : "R/power.R",
    "properties" : {
        "tempName" : "Untitled1"
    },
    "source_on_save" : false,
    "type" : "r_source"
}